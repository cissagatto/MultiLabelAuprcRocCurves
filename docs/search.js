window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "src", "modulename": "src", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.example", "modulename": "src.example", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.example.true", "modulename": "src.example", "qualname": "true", "kind": "variable", "doc": "<p></p>\n", "default_value": "     Label1  Label2  Label3  Label4  Label5  Label6  Label7  Label8\n0         1       0       0       0       0       0       0       0\n1         1       0       0       0       0       0       0       0\n2         1       0       0       0       0       0       0       0\n3         1       0       0       0       0       0       0       0\n4         1       0       0       0       0       0       0       0\n..      ...     ...     ...     ...     ...     ...     ...     ...\n134       0       0       0       0       0       0       0       1\n135       0       0       0       0       0       0       0       1\n136       0       0       0       0       0       0       0       1\n137       0       0       0       0       0       0       0       1\n138       0       0       0       0       0       0       0       1\n\n[139 rows x 8 columns]"}, {"fullname": "src.example.pred", "modulename": "src.example", "qualname": "pred", "kind": "variable", "doc": "<p></p>\n", "default_value": "     Label1  Label2  Label3  Label4  Label5  Label6  Label7  Label8\n0     1.000   0.000   0.000   0.000     0.0     0.0   0.000   0.000\n1     1.000   0.000   0.000   0.000     0.0     0.0   0.000   0.000\n2     1.000   0.000   0.045   0.000     0.0     0.0   0.025   0.000\n3     1.000   0.000   0.000   0.000     0.0     0.0   0.000   0.000\n4     1.000   0.000   0.000   0.000     0.0     0.0   0.000   0.000\n..      ...     ...     ...     ...     ...     ...     ...     ...\n134   0.000   0.000   0.005   0.000     0.0     0.0   0.000   1.000\n135   0.000   0.005   0.000   0.000     0.0     0.0   0.000   1.000\n136   0.000   0.000   0.005   0.000     0.0     0.0   0.000   1.000\n137   0.020   0.000   0.025   0.000     0.0     0.0   0.000   0.895\n138   0.005   0.000   0.030   0.095     0.0     0.0   0.000   0.970\n\n[139 rows x 8 columns]"}, {"fullname": "src.example.base_path", "modulename": "src.example", "qualname": "base_path", "kind": "variable", "doc": "<p></p>\n", "default_value": "$PWD"}, {"fullname": "src.example.data_path", "modulename": "src.example", "qualname": "data_path", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;/home/cissagatto/MultiLabelAuprcRocCurves/data&#x27;"}, {"fullname": "src.example.plots_path", "modulename": "src.example", "qualname": "plots_path", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;/home/cissagatto/MultiLabelAuprcRocCurves/plots&#x27;"}, {"fullname": "src.example.df_macro", "modulename": "src.example", "qualname": "df_macro", "kind": "variable", "doc": "<p></p>\n", "default_value": "   Fold  Macro_AUC  Macro_AUC_Interp\n0     1   0.998709          0.999007\n1     2   0.998900          0.998966\n2     3   0.936609          0.936658\n3     4   0.997692          0.997907\n4     5   0.996286          0.996416\n5     6   0.996004          0.996019\n6     7   0.990508          0.990857\n7     8   0.932460          0.932740\n8     9   0.993036          0.993653\n9    10   0.996634          0.996698"}, {"fullname": "src.example.df_micro", "modulename": "src.example", "qualname": "df_micro", "kind": "variable", "doc": "<p></p>\n", "default_value": "   Fold  Micro_AUC\n0     1   0.999014\n1     2   0.998884\n2     3   0.999293\n3     4   0.997876\n4     5   0.996138\n5     6   0.991235\n6     7   0.991709\n7     8   0.995714\n8     9   0.994960\n9    10   0.996940"}, {"fullname": "src.example.df_weighted", "modulename": "src.example", "qualname": "df_weighted", "kind": "variable", "doc": "<p></p>\n", "default_value": "   Fold  Weighted_AUC\n0     1      0.997806\n1     2      0.998084\n2     3      0.998905\n3     4      0.996691\n4     5      0.991731\n5     6      0.989558\n6     7      0.988082\n7     8      0.993687\n8     9      0.991345\n9    10      0.991794"}, {"fullname": "src.example.df_samples", "modulename": "src.example", "qualname": "df_samples", "kind": "variable", "doc": "<p></p>\n", "default_value": "   Fold  Samples_AUC\n0     1     0.996939\n1     2     0.992908\n2     3     0.995918\n3     4     0.993282\n4     5     0.991307\n5     6     0.992720\n6     7     0.983556\n7     8     0.988889\n8     9     0.987755\n9    10     0.993234"}, {"fullname": "src.example.summary_path", "modulename": "src.example", "qualname": "summary_path", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;/home/cissagatto/MultiLabelAuprcRocCurves/plots/summary_roc_auc_results.csv&#x27;"}, {"fullname": "src.example.summary", "modulename": "src.example", "qualname": "summary", "kind": "variable", "doc": "<p></p>\n", "default_value": "   Fold  Macro_AUC  Macro_AUC_Interp  Micro_AUC  Weighted_AUC  Samples_AUC\n0     1   0.998709          0.999007   0.999014      0.997806     0.996939\n1     2   0.998900          0.998966   0.998884      0.998084     0.992908\n2     3   0.936609          0.936658   0.999293      0.998905     0.995918\n3     4   0.997692          0.997907   0.997876      0.996691     0.993282\n4     5   0.996286          0.996416   0.996138      0.991731     0.991307\n5     6   0.996004          0.996019   0.991235      0.989558     0.992720\n6     7   0.990508          0.990857   0.991709      0.988082     0.983556\n7     8   0.932460          0.932740   0.995714      0.993687     0.988889\n8     9   0.993036          0.993653   0.994960      0.991345     0.987755\n9    10   0.996634          0.996698   0.996940      0.991794     0.993234"}, {"fullname": "src.ml_auprc_roc", "modulename": "src.ml_auprc_roc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.ml_auprc_roc.robust_macro_roc_auc", "modulename": "src.ml_auprc_roc", "qualname": "robust_macro_roc_auc", "kind": "function", "doc": "<p>Compute a robust macro-average ROC AUC across multiple binary labels,\nwith interpolation and explicit handling of degenerate or undefined cases.</p>\n\n<hr />\n\n<h2 id=\"description\">Description</h2>\n\n<p>For each label (column) in <code>true</code> and <code>pred</code> this function:</p>\n\n<ul>\n<li>attempts to compute the ROC curve (FPR, TPR) and AUC using\nsklearn.metrics when possible;</li>\n<li>handles special cases where <code>y_true</code> has no class variation\n(all zeros or all ones) or where predictions are constant or binary;</li>\n<li>assigns deterministic AUC values for such edge cases to ensure\nnumerical stability and interpretability;</li>\n<li>returns both the simple macro-average of per-label AUCs and the AUC\nof the interpolated mean ROC curve.</li>\n</ul>\n\n<hr />\n\n<h2 id=\"objective\">Objective</h2>\n\n<p>Provide a stable and interpretable macro-averaged ROC-AUC metric for\nmulti-label problems, even when some labels cannot produce a valid ROC\ncurve under the standard definition (e.g., labels with no positive\nexamples). The interpolated mean ROC offers an alternative aggregate\nsummary by averaging TPRs on a common FPR grid.</p>\n\n<hr />\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>true : pandas.DataFrame\n    Ground-truth binary indicators (0 or 1) for each label (columns).\n    Each column represents a distinct label and all columns must have\n    the same number of rows.</p>\n\n<p>pred : pandas.DataFrame\n    Predicted scores or probabilities for each label (columns must match\n    <code>true</code> and be in the same order). May contain binary values (0/1)\n    or continuous probabilities in [0, 1].</p>\n\n<p>verbose : bool, default=True\n    If True, prints a per-label message describing the handled case and\n    the resulting AUC, and prints final macro statistics.</p>\n\n<hr />\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple: (fpr_dict_macro, tpr_dict_macro, macro_auc, macro_auc_interp, macro_auc_df)</p>\n\n<p>fpr_dict_macro : dict\n    Mapping from label name to the array of False Positive Rates used\n    to build the ROC for that label. For special-case labels, returns\n    standardized arrays (e.g., [0.0, 1.0]).</p>\n\n<p>tpr_dict_macro : dict\n    Mapping from label name to the array of True Positive Rates for that\n    label. For special-case labels, returns standardized arrays such as\n    [0.0, 1.0] or [0.0, 0.0] depending on the case.</p>\n\n<p>macro_auc : float\n    The simple arithmetic mean of the per-label AUC values (including\n    substituted AUCs for degenerate labels).</p>\n\n<p>macro_auc_interp : float\n    The AUC computed from the interpolated mean ROC curve. The mean ROC\n    curve is obtained by:\n      1) forming a common set of FPR points across labels,\n      2) interpolating each label's TPR onto that grid,\n      3) averaging the interpolated TPRs and computing AUC over the grid.</p>\n\n<p>macro_auc_df : pandas.DataFrame\n    DataFrame with one row per label and columns:\n      - \"Label\": label name\n      - \"AUC\": computed or assigned AUC value\n      - \"FPR\": array of False Positive Rates (object dtype)\n      - \"TPR\": array of True Positive Rates (object dtype)</p>\n\n<hr />\n\n<h2 id=\"special-case-assignment-summary\">Special-case assignment summary</h2>\n\n<ul>\n<li>y_true all 0 and y_pred all 0  \u2192 AUC = 1.0</li>\n<li>y_true all 1 and y_pred all 1  \u2192 AUC = 1.0</li>\n<li>y_true all 0 and y_pred all 1  \u2192 AUC = 0.0</li>\n<li>y_true all 1 and y_pred all 0  \u2192 AUC = 0.0</li>\n<li>y_true constant (0 or 1) and y_pred probabilistic (not only 0/1)\n\u2192 AUC = 0.5</li>\n<li>y_true all 1 and y_pred mixed {0,1} \u2192 AUC = 1.0</li>\n<li>y_true all 0 and y_pred mixed {0,1} \u2192 AUC = 0.0</li>\n<li>sklearn ROC computation error (ValueError) \u2192 AUC = 0.0</li>\n<li>other fallback cases \u2192 AUC = 0.5</li>\n</ul>\n\n<hr />\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">pandas</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">pd</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">sklearn.datasets</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">make_multilabel_classification</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Generate example multi-label data</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">Y</span> <span class=\"o\">=</span> <span class=\"n\">make_multilabel_classification</span><span class=\"p\">(</span><span class=\"n\">n_samples</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">n_features</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                                      <span class=\"n\">n_classes</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">random_state</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">true</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">,</span> <span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s2\">&quot;Label1&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Label2&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Label3&quot;</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">rng</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">default_rng</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pred</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">({</span>\n<span class=\"gp\">... </span>    <span class=\"s2\">&quot;Label1&quot;</span><span class=\"p\">:</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>    <span class=\"s2\">&quot;Label2&quot;</span><span class=\"p\">:</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>    <span class=\"s2\">&quot;Label3&quot;</span><span class=\"p\">:</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"gp\">... </span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fpr_dict</span><span class=\"p\">,</span> <span class=\"n\">tpr_dict</span><span class=\"p\">,</span> <span class=\"n\">macro_auc</span><span class=\"p\">,</span> <span class=\"n\">macro_auc_interp</span><span class=\"p\">,</span> <span class=\"n\">macro_df</span> <span class=\"o\">=</span> <span class=\"n\">robust_macro_roc_auc</span><span class=\"p\">(</span><span class=\"n\">true</span><span class=\"p\">,</span> <span class=\"n\">pred</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Macro AUC (mean): </span><span class=\"si\">{</span><span class=\"n\">macro_auc</span><span class=\"si\">:</span><span class=\"s2\">.4f</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Macro AUC (interpolated): </span><span class=\"si\">{</span><span class=\"n\">macro_auc_interp</span><span class=\"si\">:</span><span class=\"s2\">.4f</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">macro_df</span><span class=\"p\">[[</span><span class=\"s2\">&quot;Label&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;AUC&quot;</span><span class=\"p\">]])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">true</span>, </span><span class=\"param\"><span class=\"n\">pred</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.ml_auprc_roc.robust_micro_roc_auc", "modulename": "src.ml_auprc_roc", "qualname": "robust_micro_roc_auc", "kind": "function", "doc": "<p>Compute a robust micro-average ROC-AUC score with special-case handling.</p>\n\n<hr />\n\n<h2 id=\"description\">Description</h2>\n\n<p>This function calculates the micro-averaged ROC-AUC score for multilabel\nclassification tasks, with robust handling of degenerate cases such as:</p>\n\n<ul>\n<li>All labels being 0 or 1.</li>\n<li>Model predicting a single constant value.</li>\n<li>Lack of positive or negative samples.</li>\n<li>Probabilistic predictions when the ground truth is constant.</li>\n</ul>\n\n<p>Unlike <code>sklearn.metrics.roc_auc_score</code>, this implementation avoids NaN\nor undefined results by explicitly assigning AUC values (0.0, 0.5, or 1.0)\nin these special scenarios.</p>\n\n<hr />\n\n<h2 id=\"objective\">Objective</h2>\n\n<p>Provide a consistent and interpretable AUC_micro value even when\nsome edge cases occur \u2014 particularly useful in highly imbalanced\nmultilabel problems or small datasets.</p>\n\n<hr />\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>true : pandas.DataFrame\n    Ground-truth binary labels of shape (n_samples, n_classes).</p>\n\n<p>pred : pandas.DataFrame\n    Predicted probabilities or binary predictions of the same shape.</p>\n\n<p>verbose : bool, optional (default=True)\n    If True, prints diagnostic messages about which special case\n    was applied and the computed AUC value.</p>\n\n<hr />\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>fpr_micro : numpy.ndarray\n    False Positive Rate values for the micro-averaged ROC curve.</p>\n\n<p>tpr_micro : numpy.ndarray\n    True Positive Rate values for the micro-averaged ROC curve.</p>\n\n<p>auc_micro : float\n    The computed micro-average AUC value. Guaranteed to be numeric\n    and well-defined (never NaN).</p>\n\n<hr />\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">pandas</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">pd</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">true</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">({</span>\n<span class=\"gp\">... </span>    <span class=\"s1\">&#39;Label1&#39;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>    <span class=\"s1\">&#39;Label2&#39;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"gp\">... </span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pred</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">({</span>\n<span class=\"gp\">... </span>    <span class=\"s1\">&#39;Label1&#39;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>    <span class=\"s1\">&#39;Label2&#39;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">]</span>\n<span class=\"gp\">... </span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fpr_micro</span><span class=\"p\">,</span> <span class=\"n\">tpr_micro</span><span class=\"p\">,</span> <span class=\"n\">auc_micro</span> <span class=\"o\">=</span> <span class=\"n\">robust_micro_roc_auc</span><span class=\"p\">(</span><span class=\"n\">true</span><span class=\"p\">,</span> <span class=\"n\">pred</span><span class=\"p\">)</span>\n<span class=\"go\">&lt;h2 id=&quot;printfmicro-average-auc-auc_micro4f&quot;&gt;&gt;&gt;&gt; print(f&quot;Micro-average AUC: {auc_micro:.4f}&quot;)&lt;/h2&gt;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">true</span>, </span><span class=\"param\"><span class=\"n\">pred</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.ml_auprc_roc.robust_weighted_roc_auc", "modulename": "src.ml_auprc_roc", "qualname": "robust_weighted_roc_auc", "kind": "function", "doc": "<p>Compute a robust, weighted-average ROC-AUC across multiple labels,\nhandling special cases where ROC curves are undefined.</p>\n\n<hr />\n\n<h2 id=\"description\">Description</h2>\n\n<p>For each label (column) in <code>true</code> and <code>pred</code>, this function:</p>\n\n<ul>\n<li>Computes the ROC curve (FPR, TPR) and AUC in normal cases.</li>\n<li>Handles edge cases where <code>y_true</code> contains only one class (all zeros\nor all ones), or where predictions are constant or binary-only.</li>\n<li>Defines deterministic AUC values for these cases to ensure numerical\nstability and interpretability.</li>\n<li>Aggregates individual label AUCs into a weighted-average score,\nusing the number of positive samples as weights.</li>\n</ul>\n\n<hr />\n\n<h2 id=\"objective\">Objective</h2>\n\n<p>To provide a stable and interpretable computation of the weighted-average\nROC-AUC for multi-label data, even when certain labels have no variance or\nwhen predicted scores are degenerate (constant or binary).\nThe weighting ensures that labels with more positive samples have a\nproportionally greater influence on the final metric, making it suitable\nfor imbalanced multi-label datasets.</p>\n\n<hr />\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>true : pandas.DataFrame\n    Ground-truth binary indicators (0 or 1) for each label column.\n    Each column represents one label, and all columns must have\n    the same number of rows.</p>\n\n<p>pred : pandas.DataFrame\n    Predicted scores or probabilities for each label column.\n    Columns must match those in <code>true</code> and appear in the same order.\n    May contain either binary {0, 1} predictions or continuous\n    probabilities in [0, 1].</p>\n\n<p>verbose : bool, default=True\n    If True, prints a per-label message describing the computed or\n    assigned AUC, and displays the final weighted-average result.</p>\n\n<hr />\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple: (fpr_dict, tpr_dict, auc_weighted, auc_df_detailed)</p>\n\n<p>fpr_dict : dict\n    A dictionary mapping each label name to an array of False Positive\n    Rates used to construct the ROC curve.<br />\n    For special cases, standardized arrays (e.g., [0.0, 1.0]) are returned.</p>\n\n<p>tpr_dict : dict\n    A dictionary mapping each label name to an array of True Positive\n    Rates corresponding to the ROC curve.<br />\n    For special cases, arrays such as [0.0, 1.0] or [0.0, 0.0] are used.</p>\n\n<p>auc_weighted : float\n    The weighted mean of per-label AUCs, where weights are the proportion\n    of positive samples per label (<code>support_i / total_support</code>).\n    If total support is zero, equal weights are applied across labels.</p>\n\n<p>auc_df_detailed : pandas.DataFrame\n    A detailed DataFrame containing one row per label with columns:\n      - \"Label\": label name<br />\n      - \"AUC\": computed or assigned AUC value<br />\n      - \"Support\": number of positive samples in <code>true[col]</code>\n      - \"Weight\": normalized support (used for weighted averaging)<br />\n      - \"FPR\": array of False Positive Rates<br />\n      - \"TPR\": array of True Positive Rates  </p>\n\n<hr />\n\n<h2 id=\"special-case-handling-summary\">Special Case Handling Summary</h2>\n\n<ul>\n<li><code>y_true</code> all 0 and <code>y_pred</code> all 0  \u2192 AUC = 1.0  </li>\n<li><code>y_true</code> all 1 and <code>y_pred</code> all 1  \u2192 AUC = 1.0  </li>\n<li><code>y_true</code> all 0 and <code>y_pred</code> all 1  \u2192 AUC = 0.0  </li>\n<li><code>y_true</code> all 1 and <code>y_pred</code> all 0  \u2192 AUC = 0.0  </li>\n<li><code>y_true</code> constant (0 or 1) and <code>y_pred</code> probabilistic (not just 0/1)\n\u2192 AUC = 0.5  </li>\n<li><code>y_true</code> all 1, <code>y_pred</code> mixed {0,1} \u2192 AUC = 1.0  </li>\n<li><code>y_true</code> all 0, <code>y_pred</code> mixed {0,1} \u2192 AUC = 0.0  </li>\n<li>ROC computation error (ValueError) \u2192 AUC = 0.0  </li>\n<li>Any other fallback condition \u2192 AUC = 0.5  </li>\n</ul>\n\n<hr />\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">pandas</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">pd</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">sklearn.datasets</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">make_multilabel_classification</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Generate sample multilabel data</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">Y</span> <span class=\"o\">=</span> <span class=\"n\">make_multilabel_classification</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>    <span class=\"n\">n_samples</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">n_features</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">n_classes</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">random_state</span><span class=\"o\">=</span><span class=\"mi\">42</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">true</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">,</span> <span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s2\">&quot;Label1&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Label2&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Label3&quot;</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Simulate probabilistic predictions</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">rng</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">default_rng</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pred</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">({</span>\n<span class=\"gp\">... </span>    <span class=\"s2\">&quot;Label1&quot;</span><span class=\"p\">:</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>    <span class=\"s2\">&quot;Label2&quot;</span><span class=\"p\">:</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>    <span class=\"s2\">&quot;Label3&quot;</span><span class=\"p\">:</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"gp\">... </span><span class=\"p\">})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fpr_dict</span><span class=\"p\">,</span> <span class=\"n\">tpr_dict</span><span class=\"p\">,</span> <span class=\"n\">auc_weighted</span><span class=\"p\">,</span> <span class=\"n\">auc_df</span> <span class=\"o\">=</span> <span class=\"n\">robust_weighted_roc_auc</span><span class=\"p\">(</span><span class=\"n\">true</span><span class=\"p\">,</span> <span class=\"n\">pred</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Weighted ROC-AUC: </span><span class=\"si\">{</span><span class=\"n\">auc_weighted</span><span class=\"si\">:</span><span class=\"s2\">.4f</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">auc_df</span><span class=\"p\">[[</span><span class=\"s2\">&quot;Label&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Support&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Weight&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;AUC&quot;</span><span class=\"p\">]])</span>\n<span class=\"go\">Label   Support  Weight    AUC</span>\n<span class=\"go\">Label1     53.0   0.500   0.704</span>\n<span class=\"go\">Label2     31.0   0.292   0.668</span>\n<span class=\"go\">Label3     22.0   0.208   0.630</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">true</span>, </span><span class=\"param\"><span class=\"n\">pred</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.ml_auprc_roc.robust_sample_roc_auc", "modulename": "src.ml_auprc_roc", "qualname": "robust_sample_roc_auc", "kind": "function", "doc": "<p>Compute a robust sample-average ROC-AUC with special case handling and FPR/TPR tracking.</p>\n\n<hr />\n\n<h2 id=\"description\">Description</h2>\n\n<p>This function computes the <strong>samples-average ROC-AUC</strong>, which evaluates\nthe ROC-AUC per sample (row) and then averages the results.\nIt is particularly relevant for multi-label classification, where each\nsample can belong to multiple classes.</p>\n\n<p>Each sample\u2019s ROC curve (FPR, TPR) is computed individually.\nThe function also handles degenerate cases robustly:\n    - When all true labels or predictions for a sample are constant\n    - When both are all zeros or all ones (perfect cases)\n    - When true and predicted values are mismatched (inverted cases)</p>\n\n<hr />\n\n<h2 id=\"objective\">Objective</h2>\n\n<p>To compute a stable and interpretable per-sample ROC-AUC and summarize\nboth the individual and average results, even when some samples have\ndegenerate or constant values.</p>\n\n<hr />\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>true : pandas.DataFrame\n    Binary ground-truth labels (0 or 1) for each class per sample.</p>\n\n<p>pred : pandas.DataFrame\n    Predicted probabilities or binary predictions (0 or 1)\n    with the same structure as <code>true</code>.</p>\n\n<p>verbose : bool, default=True\n    If True, prints detailed information for each sample and overall stats.</p>\n\n<hr />\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sample_auc_df : pandas.DataFrame\n    DataFrame containing per-sample ROC-AUC results:\n        - \"Sample\": name of the sample (e.g., Sample1, Sample2, ...)\n        - \"AUC\": computed ROC-AUC value\n        - \"FPR\": False Positive Rate array\n        - \"TPR\": True Positive Rate array</p>\n\n<p>samples_auc_mean : float\n    Mean AUC across all samples.</p>\n\n<hr />\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">pandas</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">pd</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">true</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]],</span>\n<span class=\"gp\">... </span>                    <span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s2\">&quot;Label1&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Label2&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Label3&quot;</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pred</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">([[</span><span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">0.8</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">]],</span>\n<span class=\"gp\">... </span>                    <span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s2\">&quot;Label1&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Label2&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;Label3&quot;</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sample_auc_df</span><span class=\"p\">,</span> <span class=\"n\">samples_auc_mean</span> <span class=\"o\">=</span> <span class=\"n\">robust_sample_roc_auc</span><span class=\"p\">(</span><span class=\"n\">true</span><span class=\"p\">,</span> <span class=\"n\">pred</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">sample_auc_df</span><span class=\"p\">)</span>\n<span class=\"go\">    Sample    AUC             FPR             TPR</span>\n<span class=\"go\">0  Sample1  1.000  [0.0, 1.0]     [0.0, 1.0]</span>\n<span class=\"go\">1  Sample2  1.000  [0.0, 1.0]     [0.0, 1.0]</span>\n<span class=\"go\">2  Sample3  1.000  [0.0, 1.0]     [0.0, 1.0]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Samples average AUC = </span><span class=\"si\">{</span><span class=\"n\">samples_auc_mean</span><span class=\"si\">:</span><span class=\"s2\">.4f</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">true</span>, </span><span class=\"param\"><span class=\"n\">pred</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.ml_auprc_roc.plot_macro_roc", "modulename": "src.ml_auprc_roc", "qualname": "plot_macro_roc", "kind": "function", "doc": "<p>Plot macro-average ROC curve with optional saving and display.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fpr_dict</span>,</span><span class=\"param\">\t<span class=\"n\">tpr_dict</span>,</span><span class=\"param\">\t<span class=\"n\">macro_auc</span>,</span><span class=\"param\">\t<span class=\"n\">macro_auc_interp</span>,</span><span class=\"param\">\t<span class=\"n\">macro_df</span>,</span><span class=\"param\">\t<span class=\"n\">save_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">show</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.ml_auprc_roc.plot_micro_roc", "modulename": "src.ml_auprc_roc", "qualname": "plot_micro_roc", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fpr</span>, </span><span class=\"param\"><span class=\"n\">tpr</span>, </span><span class=\"param\"><span class=\"n\">auc_micro</span>, </span><span class=\"param\"><span class=\"n\">save_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">show</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.ml_auprc_roc.plot_weighted_roc", "modulename": "src.ml_auprc_roc", "qualname": "plot_weighted_roc", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fpr_dict</span>, </span><span class=\"param\"><span class=\"n\">tpr_dict</span>, </span><span class=\"param\"><span class=\"n\">auc_weighted</span>, </span><span class=\"param\"><span class=\"n\">auc_df</span>, </span><span class=\"param\"><span class=\"n\">save_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">show</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.ml_auprc_roc.plot_samples_auc", "modulename": "src.ml_auprc_roc", "qualname": "plot_samples_auc", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sample_auc_df</span>, </span><span class=\"param\"><span class=\"n\">save_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">show</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();